#!/usr/bin/env ts-node
/* Autogenerated generator: creates TypeScript interfaces from schema.graphql
   - Generates: input types, output (object) interfaces, enums, and resolver-class interfaces
   - Output file: src/generated/schema-types.ts

   Run with: npm run generate-schema-types
*/
import { mkdir, readFile, writeFile } from 'fs/promises'
import {
  buildASTSchema,
  GraphQLEnumType,
  GraphQLInputObjectType,
  GraphQLObjectType,
  GraphQLSchema,
  GraphQLType,
  isEnumType,
  isInputObjectType,
  isListType,
  isNonNullType,
  isObjectType,
  isScalarType,
  parse
} from 'graphql'
import path from 'path'

const OUT_DIR = path.join(process.cwd(), 'src', 'generated')
const OUT_FILE = path.join(OUT_DIR, 'schema-types.ts')
const SCHEMA_FILE = path.join(process.cwd(), 'schema.graphql')

const scalarMap: Record<string, string> = {
  String: 'string',
  ID: 'string',
  Int: 'number',
  Float: 'number',
  Boolean: 'boolean',
}


function unwrapTypeForScalars(type: GraphQLType, mode: 'input' | 'output'): { ts: string; nullable: boolean } {
  let nullable = true
  let t: GraphQLType = type
  if (isNonNullType(t)) {
    nullable = false
    // @ts-ignore
    t = t.ofType
  }

  let listDepth = 0
  while (isListType(t)) {
    // @ts-ignore
    t = t.ofType
    listDepth++
    if (isNonNullType(t)) {
      // inner non-null
      // @ts-ignore
      t = t.ofType
    }
  }

  const named = (t as any).name as string | undefined
  let baseTs = 'any'
  if (named) {
    // for built-in scalars use Scalars['Name']['input'|'output']
    if (scalarMap[named]) {
      baseTs = `Scalars['${named}']['${mode}']`
    } else {
      // otherwise use the named type directly
      baseTs = named
    }
  }

  let ts = baseTs
  for (let i = 0; i < listDepth; i++) ts = `Array<${ts}>`

  return { ts, nullable }
}


function makeArgsInterfaceName(parentName: string, fieldName: string) {
  return `${parentName}${capitalize(fieldName)}Args`
}

function capitalize(s: string) {
  return s.charAt(0).toUpperCase() + s.slice(1)
}

function getNamedTypeName(type: GraphQLType): string | null {
  let t: GraphQLType = type
  if (isNonNullType(t)) {
    // @ts-ignore
    t = t.ofType
  }
  while (isListType(t)) {
    // @ts-ignore
    t = t.ofType
    if (isNonNullType(t)) {
      // @ts-ignore
      t = t.ofType
    }
  }
  // @ts-ignore
  return (t as any).name || null
}

async function main() {
  const sdl = await readFile(SCHEMA_FILE, 'utf8')
  const ast = parse(sdl)
  const schema: GraphQLSchema = buildASTSchema(ast)
  const typeMap = schema.getTypeMap()

  const lines: string[] = []
  lines.push('// THIS FILE IS AUTO-GENERATED - DO NOT EDIT MANUALLY')
  lines.push('// Generated by src/scripts/generate-types.ts')
  lines.push('')
  lines.push("import { GraphQLResolveInfo } from 'graphql';")
  lines.push("import { Context } from '../context';")
  lines.push('')
  // helper nullable/input types to match existing generated style
  lines.push('export type Maybe<T> = T | null;')
  lines.push('export type InputMaybe<T> = Maybe<T>;')
  lines.push('')
  // small helper matching existing generated style
  lines.push('export type ResolverTypeWrapper<T> = Promise<T> | T;')
  lines.push('')
  lines.push('')

  // Emit Scalars mapping (built-ins + any custom scalars found in schema)
  const scalarNames: string[] = []
  for (const tn of Object.keys(typeMap)) {
    const t = typeMap[tn]
    if (!tn.startsWith('__') && isScalarType(t)) {
      scalarNames.push(tn)
    }
  }

  // canonical built-in ordering â€” always include built-in scalar mappings
  const builtinOrder = ['ID', 'String', 'Boolean', 'Int', 'Float']
  const customScalars = scalarNames.filter(n => !builtinOrder.includes(n))
  lines.push('/** All built-in and custom scalars, mapped to their actual values */')
  lines.push('export type Scalars = {')
  for (const sn of builtinOrder) {
    if (scalarMap[sn]) {
      const ts = scalarMap[sn]
      lines.push(`  ${sn}: { input: ${ts}; output: ${ts}; }`)
    } else {
      // fallback to any (shouldn't happen for builtins)
      lines.push(`  ${sn}: { input: any; output: any; }`)
    }
  }
  for (const sn of customScalars) {
    // custom scalars -> default to any
    lines.push(`  ${sn}: { input: any; output: any; }`)
  }
  lines.push('}')
  lines.push('')

  // Collect generated arg interfaces to avoid duplicates

  // Enums first
  for (const typeName of Object.keys(typeMap).sort()) {
    const type = typeMap[typeName]
    if (!typeName.startsWith('__') && isEnumType(type)) {
      const et = type as GraphQLEnumType
      const values = et.getValues().map(v => `'${v.name}'`).join(' | ')
      lines.push(`export type ${typeName} = ${values}`)
      lines.push('')
    }
  }

  // Input types
  for (const typeName of Object.keys(typeMap).sort()) {
    const type = typeMap[typeName]
    if (!typeName.startsWith('__') && isInputObjectType(type)) {
      const it = type as GraphQLInputObjectType
        lines.push(`export type ${typeName} = {`)
      const fields = it.getFields()
      for (const fName of Object.keys(fields)) {
        const field = fields[fName]
          const { ts, nullable } = unwrapTypeForScalars(field.type as GraphQLType, 'input')
          if (nullable) {
            lines.push(`  ${fName}?: InputMaybe<${ts}>`)
          } else {
            lines.push(`  ${fName}: ${ts}`)
          }
      }
        lines.push('}')
      lines.push('')
    }
  }

  // Object types -> data interfaces and collect resolver-class interfaces + arg interfaces
  const classInterfaces: Record<string, string[]> = {}
  const argInterfacesMap: Record<string, string[]> = {}

  for (const typeName of Object.keys(typeMap).sort()) {
    const type = typeMap[typeName]
    if (!typeName.startsWith('__') && isObjectType(type)) {
      const ot = type as GraphQLObjectType
      // Data output type: include all fields and __typename
      lines.push(`export type ${typeName} = {`)
      lines.push(`  __typename?: '${typeName}';`)
      const fields = ot.getFields()
      for (const fName of Object.keys(fields)) {
        const field = fields[fName]
        const { ts, nullable } = unwrapTypeForScalars(field.type as GraphQLType, 'output')
        if (nullable) {
          lines.push(`  ${fName}: Maybe<${ts}>;`)
        } else {
          lines.push(`  ${fName}: ${ts};`)
        }
      }
      lines.push('}')
      lines.push('')

      // collect resolver-class method signatures
      const methodLines: string[] = []
      for (const fName of Object.keys(fields)) {
        const field = fields[fName]
        let argsType = '{}'
        if (field.args && field.args.length > 0) {
          const argsIfaceName = makeArgsInterfaceName(typeName, fName)
          argsType = argsIfaceName
          if (!argInterfacesMap[argsIfaceName]) {
            const argLines: string[] = []
            argLines.push(`export type ${argsIfaceName} = {`)
            for (const a of field.args) {
              const { ts, nullable } = unwrapTypeForScalars(a.type as GraphQLType, 'input')
              if (nullable) {
                argLines.push(`  ${a.name}?: InputMaybe<${ts}>;`)
              } else {
                argLines.push(`  ${a.name}: ${ts};`)
              }
            }
            argLines.push('}')
            argLines.push('')
            argInterfacesMap[argsIfaceName] = argLines
          }
        }

        const { ts: returnTs, nullable: returnNullable } = unwrapTypeForScalars(field.type as GraphQLType, 'output')
        const returnTypeWrapped = returnNullable ? `Maybe<${returnTs}>` : returnTs
        // If return type is an object type, return the resolver interface instead of data type
        const namedReturn = getNamedTypeName(field.type as GraphQLType)
        const returnTypeObj = namedReturn ? schema.getType(namedReturn) : null
        const isReturnObject = returnTypeObj && isObjectType(returnTypeObj)
        const finalReturnType = isReturnObject ? (returnNullable ? `Maybe<I${namedReturn}Resolver>` : `I${namedReturn}Resolver`) : returnTypeWrapped
        methodLines.push(
          `  ${fName}(args: ${argsType}, ctx?: Context, info?: GraphQLResolveInfo): ResolverTypeWrapper<${finalReturnType}>;`
        )
      }
      // Use I-prefixed resolver interface names (e.g. IQueryResolver)
      classInterfaces[`I${typeName}Resolver`] = methodLines
    }
  }

  // Emit collected arg interfaces (top-level, not nested)
  for (const k of Object.keys(argInterfacesMap)) {
    lines.push(...argInterfacesMap[k])
  }

  // Emit resolver-class interfaces
  for (const className of Object.keys(classInterfaces)) {
    lines.push(`export interface ${className} {`)
    lines.push(...classInterfaces[className])
    lines.push('}')
    lines.push('')
  }

  // Resolvers mapping type
  lines.push('export type Resolvers = IQueryResolver & IMutationResolver;')
  lines.push('')

  // Write output
  await mkdir(OUT_DIR, { recursive: true })
  const content = lines.join('\n') + '\n'
  await writeFile(OUT_FILE, content, 'utf8')
  console.log(`Wrote ${OUT_FILE}`)
}

main().catch(err => {
  console.error(err)
  process.exit(1)
})
